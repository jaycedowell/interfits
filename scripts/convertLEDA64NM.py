#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Script for converting LEDA64-NM Dada files into FITS IDI.  This script is 
also capable of grouping/combining files that were taken at the same time.
"""

import gc
import os
import re
import sys
import numpy
import getopt
from datetime import datetime

from interfits.lib import coords
from interfits.ledafits import LedaFits


# Regular expression for trying to get the stand number out of an antenna
# name
_annameRE = re.compile('^.*?(?P<id>\d{1,3})$')


def usage(exitCode=None):
	print """convertLEDA64NM.py - Given a set of Dada files generated by LEDA64-NM, 
group them by time and convert them to FITS IDI format in a variety of ways.

Usage: convertLEDA64NM.py [OPTIONS] file [file [...]]

Options:
-h, --help             Display this help information
-t, --total-power      Create a FITS IDI file containing only outrigger (stands
                       #35, #257, #258, #259, and #260) total power auto-
                       correlations (Default = no)
-s, --switching        Create a FITS IDI file containing only switching base-
                       lines (cross power spectra containing stands #35, #257, 
                       and #259) (Default = no)
-a, --average          Average down to non-switching baselines into a FITS IDI
                       file (Default = no)
-p, --time-decimation  Temporal decimation factor for use with the -a/--average
                       option (Default = 5)
-f, --freq-decimation  Frequency decimation factor for use with the -a/--average
                       option (Default = 2)
-d, --disable-phasing  Disable applying the cable delays and phasing to zenith
                       (Default = apply both)
                       
Notes: 
  1) If none of -t/--total-power, -s/--switching, or -a/--average are specifed 
  then a full-resolution FITS IDI files containing all baselines is created.
  
  2) The created FITS IDI files are saved in the current working directory.
  
  3) If cable delays are applied to the data then the resulting FITS IDI files
  will contain a CALIBRATION table that records what delays were applied.
"""
	
	if exitCode is not None:
		sys.exit(exitCode)
	else:
		return True


def parseConfig(args):
	config = {}
	# Command line flags - default values
	config['totalPower'] = False
	config['switching'] = False
	config['average'] = False
	config['fullRes'] = True
	config['tDecim'] = 5
	config['sDecim'] = 2
	config['applyPhasing'] = True
	config['args'] = []
	
	# Read in and process the command line flags
	try:
		opts, arg = getopt.getopt(args, "htsap:f:d", ["help", "total-power", "switching", "average", "time-decimation=", "freq-decimation=", "disable-phasing"])
	except getopt.GetoptError, err:
		# Print help information and exit:
		print str(err) # will print something like "option -a not recognized"
		usage(exitCode=2)
	
	# Work through opts
	for opt, value in opts:
		if opt in ('-h', '--help'):
			usage(exitCode=0)
		elif opt in ('-t', '--total-power'):
			config['totalPower'] = True
			config['fullRes'] = False
		elif opt in ('-s', '--switching'):
			config['switching'] = True
			config['fullRes'] = False
		elif opt in ('-a', '--average'):
			config['average'] = True
			config['fullRes'] = False
		elif opt in ('-p', '--time-decimation'):
			config['tDecim'] = int(value)
		elif opt in ('-f', '--freq-decimation'):
			config['sDecim'] = int(value)
		elif opt in ('-d', '--disable-phasing'):
			config['applyPhasing'] = False
		else:
			assert False
			
	# Add in arguments
	config['args'] = arg
	
	# Return configuration
	return config


def getAllBaselines(ifi):
	"""
	Return a list of all valid baselines for the provided InterFits instance.
	"""
	
	bls, ant_arr = coords.generateBaselineIds(ifi.n_ant)
	#print '@@', 'FR', len(bls)
	return bls


def getTotalPowerBaselines(ifi, stands=[35, 257, 258, 259, 260]):
	"""
	Return a list of the autocorrelations for the total power system.
	"""
	
	# Extract the stand IDs
	ant_ids = ifi.d_array_geometry['NOSTA']
	ant_nms = [int(_annameRE.match(nm).group('id')) for nm in ifi.d_array_geometry['ANNAME']]
	
	# Figure out which antenna ID each switching outrigger is
	ant_ids_outriggers = []
	for outrigger in stands:
		ant_ids_outriggers.append( ant_ids[ant_nms.index(outrigger)] )
		
	# Get a listing of all baselines
	bls = getAllBaselines(ifi)
	
	# Figure out what to keep
	blsToKeep = []
	for i in xrange(len(bls)):
		if bls[i] > 65536:
			s1 = (bls[i] - 65536) / 2048
			s2 = (bls[i] - 65536) % 2048
		else:
			s1 = bls[i] / 256
			s2 = bls[i] % 256
		if s1 == s2:
			if s1 in ant_ids_outriggers:
				blsToKeep.append( bls[i] )
				
	# Done
	#print '@@', 'TP', len(blsToKeep)
	return blsToKeep


def getSwitchingBaselines(ifi, stands=[35, 257, 259]):
	"""
	Return a list of all visibilities that contain a switching outrigger.
	"""
	
	# Extract the stand IDs
	ant_ids = ifi.d_array_geometry['NOSTA']
	ant_nms = [int(_annameRE.match(nm).group('id')) for nm in ifi.d_array_geometry['ANNAME']]
	
	# Figure out which antenna ID each switching outrigger is
	ant_ids_outriggers = []
	for outrigger in stands:
		ant_ids_outriggers.append( ant_ids[ant_nms.index(outrigger)] )
		
	# Get a listing of all baselines
	bls = getAllBaselines(ifi)
	
	# Figure out what to keep
	blsToKeep = []
	for i in xrange(len(bls)):
		if bls[i] > 65536:
			s1 = (bls[i] - 65536) / 2048
			s2 = (bls[i] - 65536) % 2048
		else:
			s1 = bls[i] / 256
			s2 = bls[i] % 256
		if s1 != s2:
			if s1 in ant_ids_outriggers or s2 in ant_ids_outriggers:
				blsToKeep.append( bls[i] )
				
	# Done
	#print '@@', 'SW', len(blsToKeep)
	return blsToKeep


def getStaticBaselines(ifi, stands=[35, 257, 259]):
	"""
	Return a list of all visibilities that do not contain a switching outrigger.
	"""
	
	# Extract the stand IDs
	ant_ids = ifi.d_array_geometry['NOSTA']
	ant_nms = [int(_annameRE.match(nm).group('id')) for nm in ifi.d_array_geometry['ANNAME']]
	
	# Figure out which antenna ID each switching outrigger is
	ant_ids_outriggers = []
	for outrigger in stands:
		ant_ids_outriggers.append( ant_ids[ant_nms.index(outrigger)] )
		
	# Get a listing of all baselines
	bls = getAllBaselines(ifi)
	
	# Figure out what to keep
	blsToKeep = []
	for i in xrange(len(bls)):
		if bls[i] > 65536:
			s1 = (bls[i] - 65536) / 2048
			s2 = (bls[i] - 65536) % 2048
		else:
			s1 = bls[i] / 256
			s2 = bls[i] % 256
		if s1 not in ant_ids_outriggers and s2 not in ant_ids_outriggers:
			blsToKeep.append( bls[i] )
			
	# Done
	#print '@@', 'AV', len(blsToKeep)
	return blsToKeep


def main(args):
	# Parse the command line
	config = parseConfig(args)
	filenames = config['args']
	
	# Inspect the files to try and figure out what is what
	metadataList = []
	for filename in filenames:
		uvw = LedaFits(verbose=False)
		metadataList.append( (filename, uvw.inspectFile(filename)) )
		
	# Group the files by start time and save the filenames and frequency ranges
	groups = []
	for filename,metadata in metadataList:
		tStart = metadata['tstart']
		chanBW = metadata['chanbw']
		freqStart = metadata['reffreq'] + (1                 - metadata['refpixel'])*chanBW
		freqStop  = metadata['reffreq'] + (metadata['nchan'] - metadata['refpixel'])*chanBW
		
		## See if this file represents the start of a new group or not
		new = True
		for group in groups:
			if tStart == group[0]:
				new = False
				group[1].append(filename)
				group[2].append((freqStart,freqStop,chanBW))
				break
				
		## A new group has been found
		if new:
			group = [tStart, [filename,], [(freqStart,freqStop,chanBW),]]
			groups.append(group)
			
	# Report
	print "Got %i files with groupings:" % len(filenames)
	validity = []
	for i,group in enumerate(groups):
		## Sort the group by frequency
		freqs = []
		for start,stop,cbw in group[2]:
			freqs.append(start)
		freqOrder = [j[0] for j in sorted(enumerate(freqs), key=lambda x:x[1])]
		group[1] = [group[1][j] for j in freqOrder]
		group[2] = [group[2][j] for j in freqOrder]
		
		## Report and validate
		print "  Group #%i" % (i+1,)
		print "    -> start time %s (%.2f)" % (datetime.utcfromtimestamp(group[0]), group[0])
		valid = True
		for j,(name,(start,stop,chanBW)) in enumerate(zip(group[1], group[2])):
			### Check for frequency continuity
			try:
				freqDiff = start - oldStop
			except NameError:
				freqDiff = chanBW
			oldStop = stop
			if freqDiff != chanBW:
				valid = False
				
			### Report on this file
			print "      %i: %s from %.2f to %.2f MHz" % (j+1, os.path.basename(name), start/1e6, stop/1e6)
		validity.append(valid)
		print "    -> valid set? %s" % valid
		
		## Reset the validity between groups
		del oldStop
	print " "
	
	# Combine
	for i,(valid,group) in enumerate(zip(validity,groups)):
		print "Combining group #%i..." % (i+1,)
		
		## Jump over invalid groups
		if not valid:
			print "  -> invalid, skipping"
			continue
			
		## Read in the files
		uvws = []
		for filename in group[1]:
			uvws.append( LedaFits(filename, verbose=False) )
			
		## Build the output name
		obsDate = datetime.strptime(uvws[0].date_obs, "%Y-%m-%dT%H:%M:%S")
		if len(group[1]) > 1:
			outname = "%s_%s_%s_comb%i.FITS_" % (uvws[0].instrument, uvws[0].telescope, obsDate.strftime("%Y%m%d%H%M%S"), len(uvws))
		else:
			obsFreq = int((uvws[0].formatFreqs()).mean() / 1e6)
			outname = "%s_%s_%s_%iMHz.FITS_" % (uvws[0].instrument, uvws[0].telescope, obsDate.strftime("%Y%m%d%H%M%S"), obsFreq)
		print "  -> group file basename will be '%s*'" % outname
		
		## Make a note of lowest frequency value
		freq_min = numpy.min(uvws[0].formatFreqs())
		
		## Concatenate together the various FLUX sets
		if len(uvws) > 1:
			timeBL = uvws[0].d_uv_data["FLUX"].shape[0]
			freqPolComp = uvws[0].d_uv_data["FLUX"].shape[1]
			new_uv_data = numpy.zeros((timeBL, freqPolComp*len(group[1])), dtype=uvws[0].d_uv_data["FLUX"].dtype)
			for i,uvw in enumerate(uvws):
				new_uv_data[:,i*freqPolComp:(i+1)*freqPolComp] = 1.0*uvw.d_uv_data["FLUX"]
			uvws[0].d_uv_data["FLUX"] = new_uv_data
			
		## Overwrite frequency axis keywords so that we can export UV_DATA table correctly
		uvws[0].h_common["REF_FREQ"] = freq_min
		uvws[0].h_common["REF_PIXL"] = 1
		uvws[0].h_common["NO_CHAN"]  *= len(group[1])
		uvws[0].h_params["NCHAN"] = uvws[0].h_common["NO_CHAN"] 
		uvws[0].d_frequency["TOTAL_BANDWIDTH"]  *= len(group[1])
		
		## Remove the other LedaFits instances since we only need the first one now
		while len(uvws) > 1:
			del uvws[-1]
			
		## Add in the UVW coordinates
		uvws[0].generateUVW(src='ZEN', use_stored=False, update_src=True)
		
		if config['applyPhasing']:
			## Apply the cable delays
			uvws[0].apply_cable_delays()
			
			## Phase to zenith
			uvws[0].phase_to_src(src='ZEN')
		else:
			## Update the outname to reflect the fact that no phasing as been applied
			outname = "%sNoPhasing_" % outname
			
		## Save
		if config['fullRes']:
			### Extract all possible baselines
			bls = getAllBaselines(uvws[0])
			uvws[0].select_baselines(bls)
			
			### Verify
			uvws[0].verify()
			
			### Save as FITS IDI
			uvws[0].exportFitsidi(outname+'1')
			
			### Cleanup the associated XML file
			try:
				xmlname = outname+'1.xml'
				os.unlink(xmlname)
			except OSError:
				pass
				
		if config['totalPower']:
			### Extract the total power at full resolution
			bls = getTotalPowerBaselines(uvws[0])
			uvws[0].select_baselines(bls)
			
			### Verify
			uvws[0].verify()
			
			### Save as FITS IDI
			uvws[0].exportFitsidi(outname+'TP')
			
			### Cleanup the associated XML file
			try:
				xmlname = outname+'TP.xml'
				os.unlink(xmlname)
			except OSError:
				pass
				
		if config['switching']:
			### Extract the switching baselines at full resolution
			bls = getSwitchingBaselines(uvws[0])
			uvws[0].select_baselines(bls)
			
			### Verify
			uvws[0].verify()
			
			### Save as FITS IDI
			uvws[0].exportFitsidi(outname+'SW')
			
			### Cleanup the associated XML file
			try:
				xmlname = outname+'SW.xml'
				os.unlink(xmlname)
			except OSError:
				pass
				
		if config['average']:
			### Extract the static baselines
			bls = getStaticBaselines(uvws[0])
			uvws[0].select_baselines(bls)
			
			### Decimate within a try...expect block to deal with bad decimation parameters
			try:
				uvws[0].average_time_frequency(config['tDecim'], config['sDecim'])
			except RuntimeError, e:
				print "ERROR: %s" % str(e)
				continue
				
			### Verify
			uvws[0].verify()
			
			### Save as FITS IDI
			uvws[0].exportFitsidi(outname+'AV')
			
			### Cleanup the associated XML file
			try:
				xmlname = outname+'AV.xml'
				os.unlink(xmlname)
			except OSError:
				pass
				
		## Cleanup
		del uvws[0]
		gc.collect()


if __name__ == "__main__":
	main(sys.argv[1:])
